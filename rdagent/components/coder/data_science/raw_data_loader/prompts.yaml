spec:
  system: |-
    您是一位世界级的数据科学家和机器学习工程师，拥有统计学、数学和计算机科学的深厚专业知识。
    您的知识涵盖了最先进的数据分析技术、先进的机器学习算法及其解决复杂现实问题的实际应用。

    当前，您正在进行一个 Kaggle 比赛项目。
    该项目涉及分析数据并构建模型以击败其他竞争者，代码由大型语言模型生成。

    您正在使用的运行时环境包括以下库及其对应版本：
    {{ runtime_environment }}

    您的总体任务如下：
    {{ task_desc }}

    您的任务是根据提供的比赛信息，为以下任务编写五个规范文本（以 markdown 格式）：
    - 数据加载（及预处理）
    - 特征工程
    - 模型构建
    - 集成
    - 整体工作流程

    每个步骤的规范应根据提供的比赛信息量身定制。

    您的规范应包括两个部分：
    1. 代码格式的函数定义，包括类型注释和清晰完整的文档字符串，描述函数的用途、输入参数、返回值以及任何相关的异常。
    2. 实现函数时编码人员应考虑的其他信息或注意事项。

    您的规范应仅包括函数定义和文档字符串，不包含任何代码实现或内联注释。

    ## 此任务的比赛信息
    {{ competition_info }}

    ----------- 文件夹描述（所有路径均相对于数据文件夹） ---------
    - 确保可以生成 sample_submission 中的所有列。
    {{ folder_spec }}

  user:
    data_loader: |-
      数据加载器规范文本应遵循以下详细要求：
      1. 函数接口：
        - 函数名称：`load_data`
        - 输入：无输入参数。
        - 输出：
          - `X`（DT，根据比赛信息定义）：训练数据的特征矩阵。
          - `y`（DT）：训练数据的目标向量。
          - `X_test`（DT）：测试数据的特征矩阵。
          - `test_ids`（DT）：测试数据的标识符。
        - 文档字符串要求：
          - 描述函数的用途。
          - 指定数据源位置（`{% include "scenarios.data_science.share:scen.input_path" %}`）。
          - 清楚地定义输出的结构和类型。
          - 推断每个输入和输出数据变量的数据形状。对于不确定的维度，使用 -1。
      2. 注意事项：
        - 根据具体比赛数据集更新 `DT`（数据类型）。这可以包括 `pd.DataFrame`、`np.array`、`torch.Tensor` 等。
        - 仅设置变量的 `DT`，而不推断这些变量的形状，因为您不知道数据的形状。

      实现的数据加载器的职责和注意事项应与生成的规范保持一致。
      {% include "scenarios.data_science.share:component_spec.DataLoadSpec" %}

      {% if latest_spec %}
      6. 之前的规范：
        {{ latest_spec }}
        你应遵循提供的规范以改进此任务。
      {% endif %}

      ## 输出格式
      你应直接以 markdown 格式返回规范，其中的**函数定义**应以代码格式呈现，并根据比赛信息量身定制，在文档字符串中提供详细说明。

    feature: |-
      特征工程规范文本应遵循以下要求：
      1. 函数接口：
        - 函数名称：`feat_eng`
        - 参数：
          - `X`（DT）：要转换的训练数据。
          - `y`（DT）：训练标签数据。
          - `X_test`（DT）：测试数据。
        - 输出：
          - `X_transformed`（DT）：转换后的训练数据。
          - `y_transformed`（DT）：转换后的训练标签数据。
          - `X_test_transformed`（DT）：转换后的测试数据。
        - 文档字符串要求：
          - 描述函数的用途。
          - 澄清输入参数及其数据类型。
          - 定义输出的结构和格式。
          - 推断每个输入和输出数据变量的数据形状。对于不确定的维度，使用 -1。

      2. 特征工程注意事项：
        - 妥善处理数据形状：
          - 训练数据和测试数据的样本量在所有场景中应相同。
          - 对于某些表格或时间序列数据，可能会添加或删除某些列，因此推断的列数可能不确定。
          - 对于每个维度没有特殊含义的场景（如图像、音频等），输入形状和输出形状在大多数情况下应完全相同，除非有充分的理由进行更改。
        - 与模型管道的集成：
          - 如果将特征工程推迟到模型管道以获得更好的整体性能，请明确说明将在模型阶段处理。
            - 此步骤中不应实现与模型相关的操作。（例如，它使用与模型结合的工具，如具有丰富数据转换/增强的 torch.Dataset）
          - 否则，确保此函数应用所有必需的转换，同时避免数据泄漏。
        - 一般考虑事项：
          - 确保对大数据集的可扩展性。
          - 适当处理缺失值和异常值（例如，插补、删除或替换）。
          - 确保特征数据类型和转换的一致性。
          - 防止数据泄漏：在转换训练数据时，不要使用从测试集派生的信息。
        - 特定领域特征：
          - 应用与比赛特定特征相关的逻辑（例如，文本向量化、图像增强、分类编码）。

      3. 代码标准：
        - 实现中避免使用进度条（例如，`tqdm`）。          

      4. 注意事项：
        - 将 `DT`（数据类型）定义与数据加载器规范中的定义对齐。
        - 可用 GPU 和多处理，鼓励加速转换。
        - 仅设置变量的 `DT`，而不推断这些变量的形状，因为您不知道数据的形状。
      
      {% if latest_spec %}
      5. 之前的规范：
        {{ latest_spec }}
        你应遵循提供的规范以改进此任务。
      {% endif %}

      ## 输出格式
      你应直接以 markdown 格式返回规范，其中的**函数定义**应以代码格式呈现，并根据比赛信息量身定制，在文档字符串中提供详细说明。

    model: |-
      模型构建规范文本应遵循以下要求：

      1. 函数接口：
        - 函数名称：`model_workflow`
        - 参数：
          - `X`（DT）：训练特征数据。
          - `y`（DT）：训练标签数据。
          - `val_X`（Optional[DT]）：验证特征数据。
          - `val_y`（Optional[DT]）：验证标签数据。
          - `test_X`（Optional[DT]）：测试特征数据。
          - `hyper_params`（dict）：用于模型配置的超参数字典。
        - 输出：
          - `pred_val`（Optional[DT]）：对验证数据的预测。
          - `pred_test`（Optional[DT]）：对测试数据的预测。
          - `hyper_params`（dict）：训练后更新的超参数字典。
        - 文档字符串要求：
          - 描述函数的用途。
          - 澄清输入参数及其数据类型。
          - 定义输出的结构和格式。
          - 推断每个输入和输出数据变量的数据形状。对于不确定的维度，使用 -1。

      2. 代码标准：
        - 实现中不要使用进度条（例如，`tqdm`）。

      3. 注意事项：
        - 确保输入数组（`X`、`y`、`val_X`、`val_y`、`test_X`）具有一致的维度和形状。
        - 如果未提供 `hyper_params`，则使用超参数的默认值。
        - 在 `X` 和 `y` 上训练模型。
        - 如果有验证数据，则使用 `val_X` 和 `val_y` 评估模型。
        - 如果提供了 `test_X`，则生成对其的预测。

      4. 注意事项：
        - 将 `DT`（数据类型）与特征工程规范中使用的定义对齐。
        - 设备支持 GPU，因此鼓励在必要时使用它进行加速训练。
        - 可以在此步骤中包含某些数据转换/增强（例如，TensorFlow 和 Torch 提供的数据工具）

      {% if latest_spec %}
      5. 之前的规范：
        {{ latest_spec }}
        你应遵循提供的规范以改进此任务。
      {% endif %}

      ## 输出格式
      你应直接以 markdown 格式返回规范，其中的**函数定义**应以代码格式呈现，并根据比赛信息量身定制，在文档字符串中提供详细说明。

    ensemble: |-
      集成规范文本应遵循以下要求：
      1. 函数接口：
        - 函数名称：`ensemble_workflow`
        - 参数：
          - `test_preds_dict`（Dict[str, DT]）：来自不同模型的测试预测字典。键是模型文件名。
          - `val_preds_dict`（Dict[str, DT]）：来自不同模型的验证预测字典。键是模型文件名。
          - `val_label`（DT）：验证标签。
        - 输出：
          - `final_pred`（DT）：测试数据的集成预测。
        - 文档字符串要求：
          - 描述函数的用途。
          - 澄清输入参数及其数据类型。
          - 定义输出的结构和格式。
          - 推断每个输入和输出数据变量的数据形状。对于不确定的维度，使用 -1。

      2. 注意事项：
        - 输入验证：
          - 确保 `test_preds_dict` 和 `val_preds_dict` 中的所有预测具有一致的形状和维度。
          - 验证 `val_label` 是否提供，并与 `val_preds_dict` 预测的长度匹配。
          - 处理空或无效输入时，提供适当的错误信息。
        - 指标计算和存储：
          - 计算每个模型和集成策略在验证集上的指标（在比赛信息的评估部分提到），并将结果保存在 `scores.csv` 中，例如：
            ```python
            scores = {}
            for model_name, val_pred in val_preds_dict.items():
                scores[model_name] = calculate_metric(val_label, val_pred)
            
            ...
            关于集成策略的代码
            ...
            ensemble_val_pred = ...

            ensemble_score = calculate_metric(val_label, ensemble_val_pred)
            scores["ensemble"] = ensemble_score  # 确保明确存储 "ensemble"
            
            scores_df = pd.DataFrame(scores.items(), columns=["Model", <metric_name>])
            scores_df.to_csv("scores.csv", index=False)
            ```
          - 即使只有一个模型，也要计算集成分数，并将其存储在 `"ensemble"` 下。
        
      3. 代码标准：
        - 代码中不要使用进度条（例如，tqdm）。

      4. 注意事项：
        - 将 `DT`（数据类型）定义与模型规范中使用的定义对齐。
        - 确保灵活性以处理基于比赛要求的多种集成策略。
        - 仅设置变量的 `DT`，而不推断这些变量的形状，因为您不知道数据的形状。

      {% if latest_spec %}
      5. 之前的规范：
        {{ latest_spec }}
        你应遵循提供的规范以改进此任务。
      {% endif %}

      ## 输出格式
      你应直接以 markdown 格式返回规范，其中的**函数定义**应以代码格式呈现，并根据比赛信息量身定制，在文档字符串中提供详细说明。

    workflow: |-
      {% include "scenarios.data_science.share:component_spec.Workflow" %}

      {% if latest_spec %}
      7. 之前的规范：
        {{ latest_spec }}
        你应遵循提供的规范以改进此任务。
      {% endif %}

      ## 输出格式
      你应直接以 markdown 格式返回规范。
      你应根据比赛信息创建规则，而不是复制要求。

data_loader_coder:
  system: |-
    您是一名世界级的数据科学家和机器学习工程师，拥有统计学、数学和计算机科学的深厚专业知识。
    您的知识涵盖了最先进的数据分析技术、先进的机器学习算法及其解决复杂现实问题的实际应用。

    ## 任务描述
    {{ task_desc }}

    {% if queried_similar_successful_knowledge|length != 0 or queried_former_failed_knowledge|length != 0 %}
    ## 此任务的相关信息
    {% endif %}
    
    {% if queried_similar_successful_knowledge|length != 0 %}
    --------- 类似任务成功实现示例 ---------
    ====={% for similar_successful_knowledge in queried_similar_successful_knowledge %} 示例 {{ loop.index }}:=====
    {{ similar_successful_knowledge.target_task.get_task_information() }}
    =====代码:=====
    {{ similar_successful_knowledge.implementation.all_codes }}
    {% endfor %} 
    {% endif %}

    {% if queried_former_failed_knowledge|length != 0 %}
    --------- 之前的失败尝试 ---------
    {% for former_failed_knowledge in queried_former_failed_knowledge %} 尝试 {{ loop.index }}:
    =====代码:=====
    {{ former_failed_knowledge.implementation.all_codes }}
    =====反馈:=====
    {{ former_failed_knowledge.feedback }}
    {% endfor %}
    {% endif %}

    ## 指南
    1. 确保数据集严格从 `{% include "scenarios.data_science.share:scen.input_path" %}` 加载，遵循 **数据文件夹描述** 中描述的确切文件夹结构，不要尝试从当前目录（`./`）加载数据。
    2. 你应避免使用 logging 模块输出信息，而应使用 print() 函数。
    3. 你应使用以下缓存装饰器来缓存函数的结果：
    ```python
    from joblib import Memory
    memory = Memory(location='{% include "scenarios.data_science.share:scen.cache_path" %}', verbose=0)
    @memory.cache```
    {% include "scenarios.data_science.share:guidelines.coding" %}
    
    ## 探索性数据分析（EDA）部分（必需）：
    - 在返回数据之前，你应始终添加一个 EDA 部分来描述数据，以帮助后续步骤更好地理解数据。
    - EDA 部分应包括但不限于以下信息，使用纯文本格式：
      - 数据的形状。
      - 数据的前 5 行。
      - 每列的数据类型。
      - 每列的缺失值数量。
      - 每列的唯一值数量。
      - 目标变量的分布。
      - 你认为对后续步骤重要的其他信息。
    - EDA 部分应以纯文本格式草拟，并通过 print 或其他类似函数发送到标准输出，字符数不超过一万，格式如下： 
      === EDA 部分开始 ===
      { 你的 EDA 输出内容 }
      === EDA 部分结束 ===
      用户将使用以下代码进行匹配： re.search(r"(.*?)=== Start of EDA part ===(.*)=== End of EDA part ===", stdout, re.DOTALL).groups()[1]
    - 一个评估代理将帮助检查 EDA 部分是否正确添加。
    - 在 EDA 部分期间，你应尽量避免向标准输出发送任何无关信息。

    ## 输出格式
    {% if out_spec %}
    {{ out_spec }}
    {% else %}
    请按照以下 JSON 格式响应代码。以下是 JSON 输出的示例结构:
    {
        "code": "作为字符串的 Python 代码."
    }
    {% endif %}

  user: |-
    --------- 比赛信息 ---------
    {{ competition_info }}

    --------- 代码规范 ---------
    {{ code_spec }}

    --------- 数据文件夹描述（所有路径均相对于数据文件夹，即 "{% include "scenarios.data_science.share:scen.input_path" %}"） ---------
    {{ folder_spec }}
    
    {% if latest_code %}
    --------- 之前的代码 ---------
    {{ latest_code }}
    {% if latest_code_feedback is not none %}
    --------- 对之前代码的反馈 ---------
    {{ latest_code_feedback }}
    {% endif %}
    之前的代码包含错误。你应根据提供的信息更正代码，确保不重复相同的错误。
    {% endif %} 

    你应严格遵循规范中提供的代码规范来实现函数。


data_loader_eval:
  system: |-
    您是一名数据科学家，负责评估 Kaggle 风格机器学习竞赛项目中的数据加载器代码。
    
    ## 任务描述
    {{ task_desc }}

    ## 数据加载器代码
    数据加载器代码位于 `load_data.py` 中：
    ```python
    {{ code }}
    ```

    ## 测试过程
    数据加载器使用以下脚本进行测试：
    ```python
    {{ test_code }}
    ```

    {% if workflow_stdout is not none %}
    ### 整个工作流考虑
    数据加载器是整个工作流的一部分。用户已执行整个管道并提供了额外的标准输出。

    **工作流代码：**
    {{ workflow_code }}

    你应评估数据加载器测试结果和整体工作流执行结果。**仅当两个测试都通过时，才批准代码。**
    {% endif %}
    
    ## 评估标准
    你将获得数据加载器测试的标准输出（`stdout`），如有适用，还有工作流测试的标准输出。

    ## 探索性数据分析（EDA）部分评估
    - 代码还生成了一些 EDA 输出，以帮助更好地理解数据。 
    - EDA 部分应以纯文本格式草拟，并通过 print 或其他类似函数发送到标准输出，字符数不超过一万，格式如下： 
      === EDA 部分开始 ===
      { 你的 EDA 输出内容 }
      === EDA 部分结束 ===
      用户将使用以下代码进行匹配： re.search(r"(.*?)=== Start of EDA part ===(.*)=== End of EDA part ===", stdout, re.DOTALL).groups()[1]
    - EDA 部分应包括但不限于以下信息，使用纯文本格式：
      - 数据的形状。
      - 数据的前 5 行。
      - 每列的数据类型。
      - 每列的缺失值数量。
      - 每列的唯一值数量。
      - 目标变量的分布。
      - 你认为对后续步骤重要的其他信息。
    你将获得 EDA 输出，你的工作是检查输出是否包含所需和足够的信息。如果未提供 EDA 输出，则应视为失败。将此评估结果放入 return_checking 部分。
    
    你的响应必须遵循以下结构化 JSON 格式:
    ```json
    {
        "execution": "描述数据加载器执行的情况，包括遇到的任何错误或问题。附上所有错误消息和完整的回溯细节，不要总结或省略任何信息。",
        "return_checking": "评估加载数据的正确性和完整性。检查缺失值、数据类型不正确、异常值或格式不一致等问题。",
        "code": "评估代码质量、可读性和遵循最佳实践的程度。考虑效率，包括代码是否利用多线程或 GPU 加速数据加载。",
        "final_decision": <true/false>
    }
    ```

  user: |-
    --------- 数据加载器测试标准输出 ---------
    {{ stdout }}   
    --------- 数据加载器 EDA 标准输出 ---------
    {% if eda_output is not none %}
    {{ eda_output }}
    {% else %}
    未提供 EDA 输出。
    {% endif %}
    {% if workflow_stdout is not none %}
    --------- 整个工作流测试标准输出 ---------
    {{ workflow_stdout }}
    {% endif %}
